/***************************************************************
Copyright (c) 2003, John Whitsitt Jr and Violating Networks
All rights reserved.

Redistribution and use in source and binary forms, with or
without modification, are permitted provided that the
following conditions are met:

Redistributions of source code material must retain the
above copyright notice, this list of conditions and the
following disclaimer. Redistributions in binary form must
reproduce the above copyright notice, this list of
conditions and the following disclaimer in the
documentation and/or other materials provided with the
distribution. Neither the name of the Violating Networks
collective  nor the names of its contributors may be used
to endorse or promote products derived from this software
without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
*****************************************************************/
/****************************************************************

Program:  Switchcore
Version:  beta-1

Purpose:  Receives Source-IP's from an IDS via a FIFO named
          pipe and adds an iptables marking rule for that IP.
          Checks in the background for marking rules that
          have expired and removes them. Provides protection
          from DoS abuse.

Author:	  Jack Whitsitt and Violating Networks

Comments: Main piece of the Bait and Switch Honeynet System
          http://www.violating.us/projects/baitnswitch

          The Bait and Switch Honeynet System combines
          NIDS's and Honeypots into a single system which
          adds an additional method of protection to network
          security architectures

 ***************************************************************/

#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <unistd.h>
#include <time.h>
#include <sys/types.h>
#include <linux/stat.h>
#include <pthread.h>
#include <unistd.h>
#include <syslog.h>
#include <errno.h>
#include <fcntl.h>


/*------------------------------------------------*/
/*************User Definable Variables*************/
/*------------------------------------------------*/
/* Most of these defines will eventually be #include'd from a file generated by the BNSconfig script. */

#include "./switch.vars"
#define DAEMONIZE 1
#define TEMP_MAXIP 900

/*---------------------------------------------*/
/*************Structure Definitions*************/
/*---------------------------------------------*/

/* Template for structure to keep track of iptables markings in place */
struct marks
{
	char * ip_addr;
	/* Not really time left. Actual time that rule should be removed. */
	long int time_left;
	/* marks[0].num_marks = number of rows. This is not used where marks[] is > 0 */
	int num_marks;
};


/* Template for structure to keep track of hostile ip's for DoS protection */
struct iplist
{
	char * ip_addr;
	/* time_marked[0] reserved for #times marked. This is not used there .time_marks[] is > 0 */
	long int time_marks[TEMP_MAXIP];
	/* iplist[0].num_ips = number or rows. This is not used there iplist[] is > 0 */
	int num_ips;
};


/* Used to communicate with logging thread */
struct logdata
{
	char * ip_addr;
	char * type;
	time_t thetime;
	/* Mutex to allow conditional variable to wake up logging thread */
	pthread_mutex_t *lock;
	/* Conditional variable that wakes up loggin thread */
	pthread_cond_t *cv;
};


/* Holds the blacklist after being read from a file */
struct blist
{
	char * ip_addr;
	int count;
};

typedef struct blist BLACK_LIST;
typedef struct logdata LOG_DATA;
typedef struct iplist IPLIST;
typedef struct marks MARKS;



/*--------------------------------------------*/
/*************Function Definitions*************/
/*--------------------------------------------*/



/* get_hostile reads from a FIFO named pipe waiting for an ip to be sent.*/
/* In this case, it's probably coming from the snort bns output plugin */

/* Sets readbuf, which is what main uses. IP is a char throughout the program */
/********/ int get_hostile(char **readbuf)
{
	FILE *fp;
	int done=0;
	unsigned int newip=0;

	umask(0);
	/* Create the FIFO file */
	mknod(FIFO_FILE, S_IFIFO|0666, 0);

	while(done<1)
	{
		fp = fopen(FIFO_FILE, "r");

		(*readbuf)=malloc(20);
		if(fgets((*readbuf), 20, fp)==0)
		{
			free (*readbuf);
			*readbuf=NULL;
			return 0;
		}
		done=1;
     }
	(*readbuf)[strlen(*readbuf)]=0x00;
	fclose(fp);
	return 1;
}




/* Checking if the variable is a local IP. We dont want to redirect */

/********/ int chk_local(char * l_addr)
{
	char * tmp_localipdef = LOCAL_IP;
	return (strcmp(l_addr, tmp_localipdef));
}




/* set_mark creates iptables mangling rule for a source ip passed to it that marks all packets from that IP with an 0x1 */
/* Updates the iplist and marks structures depending on whether or not the source ip already exists in them */
/* Also handles the incrementing or adding of rule removal times */

/********/ void set_mark(IPLIST *ip_track_f, MARKS *markings_f, char *mk_addr_f,int time_now_t, int already_f)
{
	FILE *mk_fp;
	/* First part of iptables shell command char */
	char * ipt1="iptables -A PREROUTING -i eth0 -t mangle -s ";
	/* End of the iptables shell comman char */
	char * ipt2=" -j MARK --set-mark 1";
	/* Container for the entire iptables shell command */
	char * ipt_mrk;
	/* How many source ip's are currently marked? */
	int num_marks = markings_f[0].num_marks;
	int ip_cnt = 0;
	int ip_cnt2 = 0;
	int mark_cnt = 0;
	int ip_times = 0;
	int i=0;
	int j=0;
	int num_ips=0;
	long int tmp_time=0;
	int markings_nmarks=0;
	int track_tmarks=0;

	/* If source IP hasnt been seen before or isnt in any struct */
	if (already_f==0)
	{
		/* Increment ip_track_f[0].num_ips */
		num_ips=ip_track_f[0].num_ips;
		++num_ips;
		ip_track_f[0].num_ips = num_ips;
		ip_track_f[num_ips].ip_addr=malloc(20);
		/* Add ip to ip_track_f[x].ip_addr */
		strcpy((ip_track_f[num_ips].ip_addr),mk_addr_f);
	}

	/* If source IP is in iplist struct but not marks struct */
	if (already_f<2)
	{
		ipt_mrk=malloc(sizeof(char) * (strlen(ipt1) + strlen(ipt2) + strlen(mk_addr_f) +1));
		ipt_mrk[0]=0x00;
		ipt_mrk=strcat(ipt_mrk, ipt1);
		/* Stick source IP in the middle of iptables rule char */
		ipt_mrk=strcat(ipt_mrk, mk_addr_f);
		ipt_mrk=strcat(ipt_mrk, ipt2);
		/* Create iptables mangling rule */
		mk_fp=popen(ipt_mrk,"w");
		fclose(mk_fp);

		free(ipt_mrk);
		ipt_mrk=0;

		markings_nmarks=markings_f[0].num_marks;
		++markings_nmarks;
		/* Increment marks_f[0].num_marks */
		markings_f[0].num_marks=markings_nmarks;
		markings_f[markings_nmarks].ip_addr=malloc(20);
		/* Add ip to marks_f[x].ip_addr */
		strcpy((markings_f[markings_nmarks].ip_addr),mk_addr_f);
	}



	/* Regardless of whether or not the Ip has been seen before: */
	/* Find IP in ip_track list */
	for (ip_cnt2=1; ip_cnt2 <= ip_track_f[0].num_ips; ip_cnt2++)
	{
		if ((strcmp(ip_track_f[ip_cnt2].ip_addr, mk_addr_f))==0)
		{
			break;
		}
	}

	track_tmarks=ip_track_f[ip_cnt2].time_marks[0];
	++track_tmarks;
	/* Increment ip_track_f[(what#is mk_addr_f)]_f.time_marks[0] */
	ip_track_f[ip_cnt2].time_marks[0]=track_tmarks;
	/* Add new current time to iplist struct for this source */
	ip_track_f[ip_cnt2].time_marks[(ip_track_f[ip_cnt2].time_marks[0])]=time_now_t;

	/* Look for source IP in marks structure */
	for (ip_cnt=1; ip_cnt <= markings_f[0].num_marks; ip_cnt++)
	{
		if ((strcmp(markings_f[ip_cnt].ip_addr, mk_addr_f))==0)
		{
			break;
		}
	}

	/* If the IP has been already marked, add more time to existing */
	if ((markings_f[ip_cnt].time_left) > time_now_t)
	{
		markings_f[ip_cnt].time_left += (MARK_INCREMENT*60);
	}
	/* If the IP has not been marked, set time to time-from-now */
	else {
		markings_f[ip_cnt].time_left = (time_now_t+(MARK_INCREMENT*60));
	}
}




/* sort_marks bubble sorts markings struct in order of most time remaining until unmark to least time remaining. */

/********/ void sort_marks(MARKS *markings_f)
{
	int i=0;
	int j=0;
	char * tmp_addr;
	time_t tmp_time;
	time_t longest;

	for (i=1; i <= (markings_f[0].num_marks); i++)
	{
		longest=markings_f[i].time_left;
		for (j=1; j<=(markings_f[0].num_marks); j++)
		{
			if((markings_f[j].time_left) < longest)
			{
				strcpy(tmp_addr,markings_f[i].ip_addr);
				tmp_time=markings_f[i].time_left;
				strcpy(markings_f[i].ip_addr,markings_f[j].ip_addr);
				markings_f[i].time_left=markings_f[j].time_left;
				strcpy(markings_f[j].ip_addr,tmp_addr);
				markings_f[j].time_left=tmp_time;
				longest=markings_f[i].time_left;
			}
		}
	}
}




/* Reverses set_mark - unmarks the ip, decrements or removes ip entry from */
/* marks struct. Doesnt touch iplist - thats maintained for history/dos reasons. */
/* Runs in it's own thread so it can be active while get_hostile blocks */

/********/ void un_mark(MARKS *markings_f)
{

	FILE *umk_fp;
	char * iptu1="iptables -D PREROUTING -i eth0 -t mangle -s ";
	char * iptu2=" -j MARK --set-mark 1";
	char * ipt_umrk;
	char * umk_addr;

	time_t ntime=0;
	int time_diff=0;
	int tleft=0;
	int loop=0;

	char * tmpmall=0;
	while(1)
	{
		/* Sleep for 3 seconds to avoid consuming access CPU */
		sleep(3);
		/* Get current time */
		ntime=time(0);

		/* Repeat next while still marks <10 seconds remaining */
		for (loop=markings_f[0].num_marks; loop>=1; loop--)
		{

			/* Get time remaining until nearest unmarking */
			/* is < 10 seconds? unmark */
			if ((markings_f[loop].time_left - ntime)<=10)
			{
				tmpmall=malloc(20);
				umk_addr=tmpmall;
				strcpy(umk_addr, markings_f[(markings_f[0].num_marks)].ip_addr);

				ipt_umrk=malloc(sizeof(char) * (strlen(iptu1) + strlen(iptu2) + strlen(umk_addr) +1));
				ipt_umrk[0]=0x00;
				ipt_umrk=strcat(ipt_umrk, iptu1);
				ipt_umrk=strcat(ipt_umrk, umk_addr);
				ipt_umrk=strcat(ipt_umrk, iptu2);

				umk_fp=popen(ipt_umrk,"w");

				fclose(umk_fp);

				/* void last line from marks struct */
				--markings_f[0].num_marks;
				free(tmpmall);
				tmpmall=0;
			}
		}
	}
}




/* checks if ip is blacklisted */

/********/ int chk_black(char * hostile_addr_f, BLACK_LIST b_list[TEMP_MAXIP])
{
	int count=b_list[0].count;
	int i=1;

	while(i<=count)
	{
		if((strcmp(hostile_addr_f, b_list[i].ip_addr))==0)
		{
			return 1;
		}
		++i;
	}

	return 0;
}




/* checks to see if multiple ip's are being alerted on very quickly, */
/* prevents them all from being marked if thats the case */

/********/ int chk_net_dos(IPLIST *ip_track_f, int time_now_t, char **type_alert)
{
	int count=0;
	time_t time_marked = time_now_t;
	int numtimes=0;
	int nummarks=ip_track_f[0].num_ips;

	while (((time_now_t-time_marked) <= NDOS_PERIOD) && (count < nummarks)){
		++count;
		numtimes=ip_track_f[count].time_marks[0];
		time_marked=ip_track_f[count].time_marks[numtimes];
	}

	if (count > NDOS_PMAX){*type_alert="chk_net_dos"; return 1;}

	return 0;

}




/* does this ip have a marking rule already? returns 1 if only iplist, 2 if in iplist and marks*/

/********/ int chk_mark(char * hostile_addr_f, IPLIST *ip_track_f, MARKS *markings_f)
{
	int exists=0;
	int num_marks=0;
	int num_ips=0;
	int loop=0;

	num_marks=markings_f[0].num_marks;

	for (loop = 1; loop <=num_marks; loop++)
	{
		if (strcmp(markings_f[loop].ip_addr,hostile_addr_f) == 0)
		{
			exists=2;
			/* Returns here because iplist will never have fewer ip's than marks does.. */
			/* so if its in marks, its in both */
			return exists;
		}
	}


	num_ips=ip_track_f[0].num_ips;

	for (loop = 1; loop <= num_ips; loop++)
	{
		if (strcmp(ip_track_f[loop].ip_addr, hostile_addr_f) == 0)
		{
			exists=1;
			return exists;
		}

	}
	return 0;
}




/* based on the # of times this ip has appeared in history, should it be blacklisted? */

/********/ void blist_chk(IPLIST *ip_track_f, char * hostile_addr_f)
{

}




/* For various dos/blacklist alerts. Only implemented in one case so far */
/********/ void log_alert(void *linfo)
{
	int fd;
	time_t time_now;
	char * part_msg1 = " was caused by Ip: ";
	char * part_msg2 = " at ";
	char * end_msg = "\n";
	char * new_ip;
	LOG_DATA *l_info;


	while(1)
	{

		l_info = (LOG_DATA *)linfo;
		/* Locks mutex to set up threading conditional variable */
		pthread_mutex_lock(l_info->lock);
		/* Threading conditional variable -> main thread wakes up this thread via l_info->cv */
		pthread_cond_wait(l_info->cv, l_info->lock);

		time(&time_now);

		new_ip=calloc((strlen(l_info->ip_addr))+1,1);
                strncpy(new_ip, l_info->ip_addr, (strlen(l_info->ip_addr)));

		/* open logfile */
		if((fd = open(LOG_DIR, O_CREAT | O_WRONLY | O_APPEND, 0600)) < 0)
		{
			perror("open");
			exit(EXIT_FAILURE);
		}


		/* Write alert type */
		write(fd, l_info->type, strlen(l_info->type));
		write(fd, part_msg1, strlen(part_msg1));
		/* Write ip */
		write(fd,new_ip, strlen(new_ip));
		write(fd,part_msg2, strlen(part_msg2));
		/* Write current time */
		write(fd,(ctime(&time_now)), strlen((ctime(&time_now))));
		/* Carriage return */
//		write(fd,end_msg, strlen(end_msg));


		close(fd);
		/* Unlock mutex so function can go back */
		pthread_mutex_unlock(l_info->lock);
	}
}




/* Are many alerts from one ip being thrown? */
/* These could be spoofed, dont redirect this ip forever...limit it. */
/* Blacklist methods elsewhere handle long-term redirection */

/********/ int chk_mark_dos(IPLIST *ip_track_f, char * hostile_addr_f, int time_now_f, char **type_alert)
{
	int pk_count=1;
	time_t last_marking=0;
	int ip_num=0;
	int nmarks=0;
	char * alert="mark_dos";

	/* Find Source IP in mark list */
	for (ip_num=1; ip_num <= ip_track_f[0].num_ips; ip_num++)
	{
		if ((strcmp(ip_track_f[ip_num].ip_addr, hostile_addr_f))==0)
		{
			break;
		}
	}

	/* How many times was this ip tracked? */
	nmarks=ip_track_f[ip_num].time_marks[0];
	/* Whats the last timestamp? */
	last_marking=ip_track_f[ip_num].time_marks[nmarks];
	/* While diff between now and last marking is < MDOS period, still may have passed limit */
	while ((time_now_f - last_marking) < MDOS_PERIOD)
	/* Continue looping until all packets within MDOS period from now have been found */
	{
		/* If more packets are found within MDOS period than are allowed, return true */
		if (pk_count > MDOS_PMAX)
		{
			*type_alert="chk_mark_dos";
			return 1;
		}

		/* Set last_marking to next earlier marking, then increment pk_count */
		last_marking=ip_track_f[ip_num].time_marks[(nmarks-pk_count)];
		++pk_count;
	}
	return 0;

}




/* gets current time. differences in time from one routine to the next are
immaterial and I think that, when referencing a single alert, the time var
should be the same until the next alert.*/
/********/ time_t get_current_time()
{
	time_t current_time;
	current_time = time(0);
	return current_time;
}



/*Reads black list from file */
/********/int read_black_list(BLACK_LIST *b_list)
{
	char * buf;

	FILE *f;
	int count=0;

	f=fopen(BLACK_FILE,"r");
	if (!f)
    	return 1;

   	buf=calloc(17,1);
	while ((!feof(f)))
	{

		fgets(buf, 17, f);
		if(strlen(buf)>6){
			++count;
			b_list[count].ip_addr=malloc((strlen(buf))+1);
			strncpy(b_list[count].ip_addr, buf, strlen(buf)-1);
			strcpy(buf,"");
			b_list[0].count=count;
			}
	}

	fclose(f);
	return 0;
}




/* If DAEMONIZE not defined, use this function for troubleshooting */
#ifndef DAEMONIZE
/********/ void tmp_printstate (IPLIST *ip_track_f, MARKS *marks_f)
{
	int num_ips=0;
	int num_marks=0;
	int num_times=0;

	printf("\n*****STRUCTS*****\n");
	for (num_marks=1; num_marks<=(marks_f[0].num_marks); num_marks++)
	{
		printf("Mark: %d	IP: %s		Time till Umark: %li\n", num_marks, marks_f[num_marks].ip_addr,marks_f[num_marks].time_left);
	}

	printf("\n");

	for (num_ips=1; num_ips<=(ip_track_f[0].num_ips); num_ips++)
	{
		printf("Ip_track#: %d	IP: %s\n", num_ips, ip_track_f[num_ips].ip_addr);
		for (num_times=1; num_times<=(ip_track_f[num_ips].time_marks[0]); num_times++)
		{
			printf("---Time# %d	Time: %li\n", num_times, ip_track_f[num_ips].time_marks[num_times]);
		}
		printf("\n");
	}
}
#endif




/*-------------------------------------------*/
/********************Main*********************/
/*-------------------------------------------*/

	/* marks struct Global to pass to thread */
	MARKS markings[TEMP_MAXIP];
	/* log struct Global to pass to thread */
	LOG_DATA loginfo;

	BLACK_LIST blk_list[TEMP_MAXIP];

int main()
{
	/* iplist struct, doesnt need to be global */
	IPLIST ip_track[TEMP_MAXIP];

	/* Hostile Address, passed to get_hostile */
	char * hostile_addr;
	/* Name of alert to log, rec'd from alert functions */
	char * logtype;
	time_t time_now;
	/* Has IP been seen before? */
	int already=0;
	time_t start;
	int skip_mark=0;
	start = time(0);
	/* Unmarking thread handle */
	pthread_t unmark_t;
	/* Logging thread handle */
	pthread_t log_alert_t;
	/* Mutex to allow main to signal logging thread */
	pthread_mutex_t lock;
	/* Conditional variable to signal logging thread */
	pthread_cond_t cv;
	/* threads started? */
	int ret, ret2;

/* Daemonizing code */
#ifdef DAEMONIZE

	pid_t pid, sid;
	/* fork, get pid */
	pid=fork();

	if(pid<0)
	{
		perror("fork");
		exit(EXIT_FAILURE);
	}

	if(pid>0)
	{
		exit(EXIT_SUCCESS);
	}

	/* Set sid */
	if((sid = setsid()) < 0)
	{
		perror("setsid");
		exit(EXIT_FAILURE);
	}

	/* Set working dir */
	if((chdir("/")) < 0)
	{
		perror("chdir");
		exit(EXIT_FAILURE);
	}

	umask(0);

	/* Close file descriptors not needed */
	close(STDIN_FILENO);
	close(STDOUT_FILENO);
	close(STDERR_FILENO);

/* End Daemon Stuff */
#endif


	/*Create Unmarking thread */
	ret=pthread_create(&unmark_t, NULL, (void *)un_mark, (void *)&markings);
	if(ret)
	{
		perror("pthread_create: un_mark");
		exit(EXIT_FAILURE);
	}
	/* End Unmarking Threading Code */


	/* Create log_alert thread */
	/* Init mutex */
	pthread_mutex_init(&lock, NULL);
	/* Init conditional variable used to wake logging thread */
	pthread_cond_init(&cv, NULL);

	loginfo.lock=&lock;
	loginfo.cv = &cv;


	ret2=pthread_create(&log_alert_t, NULL, (void *)log_alert, &loginfo);
	if(ret2)
	{
		perror("pthread_create: log_alert");
		exit(EXIT_FAILURE);
	}
	/*End log_alert threading code*/

	read_black_list(blk_list);

	/* Real Work Starts */
	while(1)
	{
		/* Skip mark: if any alerts triggered, this gets incremented. If > 0, ip not marked */
		skip_mark=0;
		/* Has IP been seen before? */
		already=0;

		/*waiting for ip to be read */
		while (!(get_hostile(&hostile_addr)))
		{
		}

		/* if it's not local, go on */
		if (chk_local(hostile_addr) !=0 )
		{
			/* if it's not on the blacklist, go on. */
			/* listed ip's are already marked and dont need to be run through the rest of the code */
			if (chk_black(hostile_addr, blk_list) != 0)
			{
				++skip_mark;
			}

			/* What time is it now? */
			time_now = get_current_time();

			/* Reset logtype */
			logtype=0;

			if (ip_track[0].num_ips >= NDOS_PMAX){
				/* Checks for multiple ip' in quick succession, log alert */
				if ((chk_net_dos(ip_track, time_now, &logtype))==1)
				{
					printf("chk_net_dos returned 1\n");
					loginfo.ip_addr=malloc(20);
					/* Copy hostile ip to logging structure */
					strncpy(loginfo.ip_addr, hostile_addr, strlen(hostile_addr));
					loginfo.type=malloc(20);
					/* Copy name of alert to logging structure */
					strcpy(loginfo.type, logtype);
					/* Signals that the logging thread needs to wake */
					pthread_cond_broadcast(loginfo.cv);
					/* Increment skip_mark so this alert doesnt have time added to it */
					++skip_mark;
				}

			}

			/* Reset Already...we dont know that yet */
			already=0;
			/* This checks to see if we've seen this hostile source before */
			already=(chk_mark(hostile_addr, ip_track, markings));

			/* If we *have* seen this source before.... */
			if (already > 0 )
			{
				/* should ip be blacklisted? */
				blist_chk(ip_track, hostile_addr);

				logtype=0;

				/* too many alerts/time? Respond same way as with chk_net_dos */
				if ((chk_mark_dos(ip_track, hostile_addr, time_now, &logtype))==1)
				{
					loginfo.ip_addr=calloc(20,1);
					strncpy(loginfo.ip_addr, hostile_addr, strlen(hostile_addr));
					loginfo.type=calloc(20,1);
					strcpy(loginfo.type, logtype);
					pthread_cond_broadcast(loginfo.cv);
					++skip_mark;
				}
			}

			/* If no alerts have been triggered...create iptables rule */
			if (skip_mark == 0)
			{
				set_mark(ip_track, markings, hostile_addr, time_now, already);
				/* sort markings in order of longest remaining time to least remaining time */
				sort_marks(markings);
			}

			}

		/* If not daemonized, print stats */
		#ifndef DAEMONIZE
		tmp_printstate(ip_track, markings);
		#endif

		}

	return 0;
}
